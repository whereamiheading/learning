1. Find nth highest salary:
select max(salary) from employee emp1 where n-1 =(select count(distinct(salary) ) from employee emp2 where emp2.salary > emp1.salary)  ;



2. dense_rank
select salary, (select count(distinct salary) from employee e2 where e2.salary > e1.salary) +1 as dr from employee e1 order by id desc ;

select score, (select count(distinct scores) from scores e2 where e2.score > e1.score) +1 as rank from scores e1 order by score desc ;

3. consecutive nums:

select  distinct l1.num
from logs l1, logs l2, logs l3
where l1.id = l2.id+1 and l2.id = l3.id +1
and l1.num = l2.num and l2.num = l3.num ;

4. employee earning more than mgr:
select e.name as Employee
from
employee e, employee m
where e.managerid =m.id
and e.salary > m.salary

5.  duplicate emails
select email from
(select Email , count(*)
from Person
group by Email
having count(Email) > 1) a;

6. customers who dont order :

select name as  customers from
customers c left join orders  o on
c.id =o.customerId
where o.id is null

7.   department with highest salary:

select d.name as department , e.name as employee, max(salary) over (partition by e.department_id order by salary desc ) as Salary
from employee e
join department d
on e.departmentid = d.id


select d.name as department  , e.name as employee , e.salary  as salary
from employee e join
(select max(salary) as salary, departmentid from employee group by departmentId) sal
on e.salary = sal.salary
and e.departmentId = sal.departmentid
join department d on e.departmentid = d.id


8. top 3 salaries from dept:


SELECT D.Name AS Department, E.Name AS Employee, E.Salary AS Salary
FROM Employee E INNER JOIN Department D ON E.DepartmentId = D.Id

WHERE (SELECT COUNT(DISTINCT(Salary)) FROM Employee
       WHERE DepartmentId = E.DepartmentId AND Salary > E.Salary) < 3

ORDER by E.DepartmentId, E.Salary DESC;


9.

delete dups:

DELETE p1
FROM Person p1, Person p2
WHERE p1.Email = p2.Email AND p1.Id > p2.Id

11.

select a.fruit, o.fruit , abs(a.sold - o.sold), a.dateid, o.dateid
from
fct_sales a
  inner join fct_sales o
on a.dateid = o.dateid
where a.fruit = 'Apple'
and o.fruit = 'Orange';

10.

select b.* from
(select sender_uid, recipient_uid from fct_request) a
inner join
(select accepter_uid , sender_uid from fct_accept) b
on  a.recipient_uid = b.accepter_uid;


  select count(a.sender_uid) ,count(b.accepter_uid), count(b.accepter_uid)/count(a.sender_uid)
  from (select distinct sender_uid, recipient_uid from fct_request) a
  left outer join
  (select distinct accepter_uid , sender_uid from fct_accept) b
  on  a.recipient_uid = b.accepter_uid;

select  friend from (
select friend, sum(cn) from
  (select sender_uid as friend, count(*)  cn
  from fct_accept
  group by sender_uid
  union all
  select accepter_uid as friend, count(*) cn
  from fct_accept
  group by accepter_uid) a
  group by friend order by sum(cn) desc

  ) c limit 1;



CREATE TABLE IF NOT EXISTS post_likes (ds VARCHAR(10), post_id INT, num_likes INT);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 105, null);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 101, 2);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 102, 7);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 103, 0);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 104, 9);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 102, 11);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 103, 2);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 104, 1);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 105, 7);
INSERT INTO post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 104, null);


Write a single query to get the count of the following for a ds
* total number of posts * total number of posts with > 0 likes

select ds,
count(distinct post_id) as tnp,
count(case when num_likes >0 then post_id else null end)  as tnpwith_1_plus_likes
from post_likes
group by ds ;

SELECT      ds, COUNT(DISTINCT post_id) AS cnt_unique_posts,
COUNT(DISTINCT CASE WHEN num_likes>0 THEN post_id ELSE NULL END) AS cnt_posts_likes

COUNT(DISTINCT IF(num_likes>0, post_id, NULL)) AS cnt_posts_likes -- or
SUM(CASE WHEN num_likes>0 THEN 1 ELSE 0 END) AS cnt_posts_likes        -- or
SUM(IF(num_likes>0, 1, 0)) AS cnt_posts_likes
;

Write a query to select the post_ids that had 0 likes on 2014-01-01 and > 0 likes on 2014-01-02.

SELECT a.post_id
FROM post_likes a
JOIN post_likes b
ON a.post_id = b.post_id
AND a.ds = '2014-01-01'
AND b.ds = '2014-01-02' AND a.num_likes = 0 AND b.num_likes > 0;




/* In real life, data may be noisy or missing. Lets say we had some post_ids that had NULL values in the num_likes column
     +--------------+------------+------------+
     | ds           | post_id | num_likes  |
     +--------------+------------+------------+
     | 2014-01-01   | 101 | 2          |
     | 2014-01-01   | 102 | 7          |
     | 2014-01-01   | 103 | 0          |
     | 2014-01-01   | 104 | 9          |
     | 2014-01-01   | 105 | NULL       | <-- new row
     | 2014-01-02   | 102 | 11         |
     | 2014-01-02   | 103 | 2          |
     | 2014-01-02   | 104 | 1          |
     | 2014-01-02   | 105 | 7          |
     +--------------+------------+-------------
     We want to treat these NULL values as zero.
     Modify the query to take this into account so that we return the post_ids of 103 & 105:</i> */



     SELECT a.post_id
     FROM post_likes a
     JOIN post_likes b
     ON a.post_id = b.post_id
     AND a.ds = '2014-01-01'
     AND b.ds = '2014-01-02'
     AND coalesce(a.num_likes , 0) = 0
     AND b.num_likes > 0;


SELECT    ds, IF(COUNT(*) = COUNT(DISTINCT post_id), 1, 0) AS test_result  FROM post_likes GROUP BY ds;
SELECT    ds, case when count(*) = count(distinct post_id) then 1 else 0 end  FROM post_likes GROUP BY ds;







CoderPad provides a basic SQL sandbox with the following schema.
You can also use commands like `show tables` and `desc employees`

employees                             projects
+---------------+---------+           +---------------+---------+
| id            | int |<----+  +->| id | int     |
| first_name    | varchar | |  | | title | varchar |
| last_name     | varchar | |  | | start_date | date    |
| salary        | int | |  | | end_date | date    |
| department_id | int     |--+ | | | budget  | int |
+---------------+---------+  | | | +---------------+---------+
                             | | |
departments                  | | | employees_projects
+---------------+---------+  | | | +---------------+---------+
| id            | int |<-+ |  +--| project_id | int     |
| name          | varchar | +-----| employee_id   | int |
+---------------+---------+           +---------------+---------+

*/
SELECT e.first_name, e.last_name, e.salary,
d.name as department_name
FROM employees   AS e
JOIN departments AS d ON e.department_id = d.id;
/*
CoderPad provides a basic SQL sandbox with the following schema.
You can also use commands like `show tables` and `desc employees`
employees                             projects
+---------------+---------+           +---------------+---------+
| id            | int |<----+  +->| id | int     |
| first_name    | varchar | |  | | title | varchar |
| last_name     | varchar | |  | | start_date | date    |
| salary        | int | |  | | end_date | date    |
| department_id | int     |--+ | | | budget  | int |
+---------------+---------+  | | | +---------------+---------+
                             | | |
departments                  | | | employees_projects
+---------------+---------+  | | | +---------------+---------+
| id            | int |<-+ |  +--| project_id | int     |
| name          | varchar | +-----| employee_id   | int |
+---------------+---------+           +---------------+---------+


Write a query to list the departments that with a higher combined salary than $40,000.


Output:

+-------------+----------------+
| name        | combined_salary|
+-------------+----------------+
| Engineering |        130000 |
| Marketing   | 50000  |
+-------------+----------------+

2 rows in set (0.00 sec)


/* Question 2:
List the current projects and employees assigned to them.
Output:
+------------+-----------+--------------------------+
| first_name | last_name | title                    |
+------------+-----------+--------------------------+
| John       | Smith | Design 3 New Silly Walks |
| Ava        | Muffinson | Build a cool site        |
| Cailin     | Ninson | Update TPS Reports       |
+------------+-----------+--------------------------+

3 rows in set (0.00 sec)


Your SQL:*/




/* Question 3:

Who's the highest paid person per department?


Output:
+------------+-----------+-------------+--------+
| first_name | last_name | name        | salary |
+------------+-----------+-------------+--------+
| John       | Smith | Reporting   | 20000 |
| Ian        | Peterson | Engineering |  80000 |
| John       | Mills | Marketing   | 50000 |
| Ava        | Muffinson | Silly Walks |  10000 |
+------------+-----------+-------------+--------+

4 rows in set (0.00 sec)



Your SQL:*/


Question 4 (previous 3) is:
/* Question 4:
Which employees are not currently assigned to any projects?

Output:
+------------+-----------+
first_name  last_name
+------------+-----------+
Mike       Peterson
Ian        Peterson
John       Mills
+------------+-----------+
3 rows in set (0.00 sec)

create table fct_sales (
  dateid date not null,
  fruit varchar(10),
  sold int
);


insert into fct_sales  values(STR_TO_DATE('2015-01-01', '%Y-%m-%d'), 'Apple', 31);
insert into fct_sales  values(STR_TO_DATE('2015-01-01', '%Y-%m-%d'), 'Orange', 19);
insert into fct_sales  values(STR_TO_DATE('2015-01-02', '%Y-%m-%d'), 'Apple', 37);
insert into fct_sales  values(STR_TO_DATE('2015-01-02', '%Y-%m-%d'), 'Orange', 26);
insert into fct_sales  values(STR_TO_DATE('2015-01-03', '%Y-%m-%d'), 'Apple', 21);
insert into fct_sales  values(STR_TO_DATE('2015-01-03', '%Y-%m-%d'), 'Orange', 21);
insert into fct_sales  values(STR_TO_DATE('2015-01-04', '%Y-%m-%d'), 'Apple', 35);

insert into fct_sales  values(STR_TO_DATE('2015-01-04', '%Y-%m-%d'), 'Orange', 27);
/*

fct_sales

+------------+--------+------+
| dateid     | fruit | sold |
+------------+--------+------+
| 2015-01-01 | Apple  | 31 |
| 2015-01-01 | Orange |   19 |
| 2015-01-02 | Apple  | 37 |
| 2015-01-02 | Orange |   26 |
| 2015-01-03 | Apple  | 21 |
| 2015-01-03 | Orange |   21 |
| 2015-01-04 | Apple  | 25 |
| 2015-01-04 | Orange |   27 |
+------------+--------+------+


Q1: What is the difference between Apples and Oranges sold each day?

create table fct_request (
  dateid date not null,
  sender_uid int,
  recipient_uid int);


insert into fct_request values(STR_TO_DATE('2015-01-01', '%Y-%m-%d'), 12345, 6789);
insert into fct_request values(STR_TO_DATE('2015-01-01', '%Y-%m-%d'), 12345, 9876);
insert into fct_request values(STR_TO_DATE('2015-01-02', '%Y-%m-%d'), 34567, 12345);
insert into fct_request values(STR_TO_DATE('2015-01-03', '%Y-%m-%d'), 9876, 1209);


create table fct_accept (
  dateid date not null,
  accepter_uid int,
  sender_uid int);

insert into fct_accept values(STR_TO_DATE('2015-01-01', '%Y-%m-%d'), 6789, 12345);
insert into fct_accept values(STR_TO_DATE('2015-01-02', '%Y-%m-%d'), 9876, 12345);
insert into fct_accept values(STR_TO_DATE('2015-01-02', '%Y-%m-%d'), 12345, 34567);

/*

fct_request

+------------+------------+---------------+
| dateid     | sender_uid | recipient_uid |
+------------+------------+---------------+
| 2015-01-01 |      12345 | 6789 |
| 2015-01-01 |      12345 | 9876 |
| 2015-01-02 |      34567 | 12345 |
| 2015-01-03 |       9876 | 1209 |
+------------+------------+---------------+

fct_accept
+------------+--------------+------------+
| dateid     | accepter_uid | sender_uid |
+------------+--------------+------------+
| 2015-01-01 |         6789 | 12345 |
| 2015-01-02 |         9876 | 12345 |
| 2015-01-02 |        12345 | 34567 |
+------------+--------------+------------+
Q1: What percent of friend requests are accepted?

Q2: Who has the most friends?


1) Post Likes

Copy the following into the coderpad header:

CREATE TABLE IF NOT EXISTS coderpad.post_likes (ds VARCHAR(10), post_id INT, num_likes INT);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 101, 2);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 102, 7);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 103, 0);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-01', 104, 9);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 102, 11);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 103, 2);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 104, 1);
INSERT INTO coderpad.post_likes (ds, post_id, num_likes) VALUES ('2014-01-02', 105, 7);
/* Table contains the number of likes a post has received on a given datestamp (ds):  post_likes
+--------------+------------+------------+
| ds           | post_id | num_likes  |
+--------------+------------+------------+
| 2014-01-01   | 101 | 2          |
| 2014-01-01   | 102 | 7          |
| 2014-01-01   | 103 | 0          |
| 2014-01-01   | 104 | 9          |
| 2014-01-02   | 102 | 11         |
| 2014-01-02   | 103 | 2          |
| 2014-01-02   | 104 | 1          |
| 2014-01-02   | 105 | 7          |
+--------------+------------+------------- */



Question 0: Warmup

/* Write a query to return the dates that have > 20 likes.
Example Output:
+------------+
| ds         |
+------------+
| 2014-01-02 |
+------------+  */

 SELECT ds  FROM post_likes   GROUP BY ds HAVING SUM(num_likes) > 20;



Question 1

/*  Write a single query to get the count of the following for a ds * total number of posts * total number of posts with > 0 likes  Example Output:
+-------------+-----------+-----------------+
| ds          | cnt_posts | cnt_posts_likes |
+-------------+-----------+-----------------+
| 2014-01-01  | 4 |      3 |
| 2014-01-02  | 4 |      4 |
+-------------+-----------+-----------------+ */

 SELECT      ds, COUNT(DISTINCT post_id) AS cnt_unique_posts,
 COUNT(DISTINCT CASE WHEN num_likes>0 THEN post_id ELSE NULL END) AS cnt_posts_likes
 -- or COUNT(DISTINCT IF(num_likes>0, post_id, NULL)) AS cnt_posts_likes
 -- or SUM(CASE WHEN num_likes>0 THEN 1 ELSE 0 END) AS cnt_posts_likes
 -- or SUM(IF(num_likes>0, 1, 0)) AS cnt_posts_likes
 FROM post_likes GROUP BY ds;



Question 2

/*  Write a query to select the post_ids that had 0 likes on 2014-01-01 and > 0 likes on 2014-01-02. E.g. it would return the post_id of 103.</b> */

 SELECT a.post_id  FROM post_likes a JOIN post_likes b  ON a.post_id = b.post_id AND a.ds = '2014-01-01'    AND b.ds = '2014-01-02' AND a.num_likes = 0 AND b.num_likes > 0;



Question 2: Followup

/* In real life, data may be noisy or missing. Lets say we had some post_ids that had NULL values in the num_likes column
+--------------+------------+------------+
| ds           | post_id | num_likes  |
+--------------+------------+------------+
| 2014-01-01   | 101 | 2          |
| 2014-01-01   | 102 | 7          |
| 2014-01-01   | 103 | 0          |
| 2014-01-01   | 104 | 9          |
| 2014-01-01   | 105 | NULL       | <-- new row
| 2014-01-02   | 102 | 11         |
| 2014-01-02   | 103 | 2          |
| 2014-01-02   | 104 | 1          |
| 2014-01-02   | 105 | 7          |
+--------------+------------+-------------
We want to treat these NULL values as zero. Modify the query to take this into account so that we return the post_ids of 103 & 105:</i> */

 SELECT a.post_id  FROM post_likes a JOIN post_likes b  ON a.post_id = b.post_id AND a.ds = '2014-01-01'
 AND b.ds = '2014-01-02' AND COALESCE(a.num_likes, 0) = 0
 -- could also use IFNULL or ISNULL
 -- or AND (a.num_likes = 0 OR a.num_likes IS NULL) AND b.num_likes > 0;



Question 3

/* Write a query to check that there is a unique post_id for each ds (i.e. no duplicate post_ids on a given date).
Return 1 if the test passes; 0 if the test fails.</b>
Example Output:     +-------------+-------------+
| ds          | test_result |
+-------------+-------------+
| 2014-01-01  | 1 |
| 2014-01-02  | 1 |
+-------------+-------------+ */

 SELECT    ds, IF(COUNT(*) = COUNT(DISTINCT post_id), 1, 0) AS test_result  FROM post_likes GROUP BY ds;



Question 3: Followup

/* Modify the query to rollup across all dates.  E.g. Return 1 if all tests pass on all dates; 0 if any test fails on any of the dates.</b>  Example Output:
+---------------------+
| overall_test_result |
+---------------------+
|          1 |
+---------------------+ */

 SELECT IF(SUM(X.test_result) = COUNT(DISTINCT X.ds), 1, 0) AS overall_test_result  FROM ( SELECT ds, IF(COUNT(*) = COUNT(DISTINCT post_id), 1, 0) AS test_result    FROM post_likes GROUP BY ds ) X;



[edit]2) Employees, Projects, Departments

/* Consider the following data schema:      employees                             projects     +---------------+---------+           +---------------+---------+     | id            | int |<----+  +->| id | int     |     | first_name    | varchar | |  | | title | varchar |     | last_name     | varchar | |  | | start_date | date    |     | salary        | int | |  | | end_date | date    |     | department_id | int     |--+ | | | budget  | int |     +---------------+---------+  | | | +---------------+---------+                              |  | |     departments                  | | | employees_projects     +---------------+---------+  | | | +---------------+---------+     | id            | int |<-+ |  +--| project_id | int     |     | name          | varchar | +-----| employee_id   | int |     +---------------+---------+           +---------------+---------+ */ <code>  <b>
Question 0: Warmup</b> <code>

/* Write a query to show all names and department of all workers.
Example Output:
+------------+-----------+-----------------+      
| first_name | last_name | department_name |
+------------+-----------+-----------------+
| John       | Smith | Reporting       |
| Cailin     | Ninson | Engineering     |
| Mike       | Peterson | Engineering     |
| Ian        | Peterson | Engineering     |
| John       | Mills | Marketing       |
| Ava        | Muffinson | Silly Walks     |
+------------+-----------+-----------------+ */

 SELECT e.first_name, e.last_name, d.name as department_name  FROM employees e JOIN departments d ON e.department_id = d.id;



Question 1

/* Write a query to list the departments with a net employee salary of more than $40,000.  Example Output:
+-------------+-----------------+
| name        | combined_salary |
+-------------+-----------------+
| Engineering |        130000 |
| Marketing   | 50000   |
+-------------+-----------------+ */

 SELECT    d.name AS department_name,    SUM(e.salary) AS combined_salary
 FROM departments d
 LEFT OUTER JOIN  employees e
 ON d.id = e.department_id
 GROUP BY d.name
 HAVING SUM(e.salary) > 40000;



Question 2

/* List the current projects and employees assigned to them.
Example Output:
+------------+-----------+--------------------------+
| first_name | last_name | title                    |
+------------+-----------+--------------------------+
| John       | Smith | Design 3 New Silly Walks |
| Ava        | Muffinson | Build a cool site        |
| Cailin     | Ninson | Update TPS Reports       |
+------------+-----------+--------------------------+ */

 SELECT    e.first_name,    e.last_name, p.title
 FROM projects p
 LEFT OUTER JOIN employees_projects ep
 ON p.id = ep.project_id
 JOIN employees e ON ep.employee_id = e.id;


Question 2: Followup to test LEFT & RIGHT OUTER JOINS

/* Modify the query to capture projects with no employees assigned and employees with no projects assigned (i.e the employees_projects table does not contain those mappings).
Assume that the employees without a project are in the employees table.
Assume that the projects without a employee are in the projects table.  Example Output:
+------------+-----------+--------------------------+
| first_name | last_name | title                    |
+------------+-----------+--------------------------+
| John       | Smith | Design 3 New Silly Walks |
| Ava        | Muffinson | Build a cool site        |
| Cailin     | Ninson | Update TPS Reports       |
| NULL       | NULL | Really Boring Project    |
| Tom       | Jones | NULL                     |
+------------+-----------+--------------------------+ */

 SELECT    e.first_name,    e.last_name, p.title
 FROM projects p
 LEFT OUTER JOIN
 employees_projects ep  ON p.id = ep.project_id
 RIGHT OUTER JOIN employees e
 ON ep.employee_id = e.id;



Question 3

/* For each department, find the highest paid person and their salary.  Example Output:
+------------+-----------+-------------+--------+
| first_name | last_name | dept_name   | salary |
+------------+-----------+-------------+--------+
| John       | Smith | Reporting   | 20000 |
| Ian        | Peterson | Engineering |  80000 |
| John       | Mills | Marketing   | 50000 |
| Ava        | Muffinson | Silly Walks |  10000 |
+------------+-----------+-------------+--------+ */

 SELECT e.first_name, e.last_name, d.name AS dept_name, A.max_salary
 FROM ( SELECT department_id, MAX(salary) AS max_salary
 FROM employees GROUP BY department_id ) A
 JOIN employees e ON e.salary = A.max_salary
 AND e.department_id = A.department_id
 JOIN departments d ON A.department_id = d.id;



Question 4

/* Which employees are not currently assigned to any projects?  Example Output:
+------------+-----------+
| first_name | last_name |
+------------+-----------+
| John       | Smith |
| Ava        | Muffinson |
| Cailin     | Ninson |
| Mike       | Peterson |
| Ian        | Peterson |
| John       | Mills |
+------------+-----------+  */

 SELECT    e.first_name,    e.last_name FROM employees e  LEFT OUTER JOIN employees_projects ep  ON e.id = ep.employee_id AND ep.project_id IS NULL;



[edit]SQL Onsite

[edit]1) DAU and MAU

Consider the following activity table that logs user actions on FB

   actions
   +--------------+-----+----------+
   | date | uid | action |
   +--------------+-----+----------+
   | 2015-01-01 | 1 | 'post' |
   | 2015-01-01 | 2 | 'like' |
   | 2015-01-01 | 2 | 'share' |
   | 2015-01-02 | 1 | 'share' |
   | 2015-01-02  | 3 | 'like' |


a) Write a query to calculate the daily active users and the monthly active users for a given date (e.g. 2015-01-01)


Example Output:

   +------+------+------+
   | date | dau | mau |
   +------+------+------|
   | 1/1 | 2 | 23 |


-- USING IF STATEMENT --

SELECT     date,     COUNT(DISTINCT IF(date = '2015-01-01', uid, NULL)) AS dau,     COUNT(DISTINCT IF(date > '2014-12-01' AND date <= '2015-01-01', uid, NULL)) AS mau,
FROM actions WHERE date > '2014-12-01' AND date <= '2015-01-01' GROUP BY date;


-- USING CASE STATEMENT --

SELECT     date,     COUNT(DISTINCT CASE WHEN date = '2015-01-01' THEN uid ELSE NULL) AS dau,
COUNT(DISTINCT CASE WHEN date > '2014-12-01' AND date <= '2015-01-01' THEN uid ELSE NULL) AS mau,
FROM actions WHERE date > '2014-12-01' AND date <= '2015-01-01' GROUP BY date;



Watch out for missing DISTINCT clause: this may lead to double counting. e.g. COUNT(uid) will count user #2 twice


b) These tables are huge (FB scale), perhaps trillions of rows per day. What sort of indexing could you use to make the table more accessible?

Partition on date

B-Tree index on date

Hash index on date


c) This query examines 30 days of data and performs expensive DISTINCT operations. As a result, this query may take many hours to complete. How could you restructure the algorithm/query to avoid such an expensive lookup?

Keep track of each user's last active date (hash index by uid) at the end of each day. Use the following update logic:

SELECT     COALESCE(a.uid, b.uid) AS uid,
            IF(b.date > a.last_active, b,date, a.last_active) AS last_active
FROM user_last_active a FULL OUTER JOIN actions b ON a.uid = b.uid;

Example Output:

   user_last_active
   +-----+---------------+
   | uid | last_active
   | +-----+---------------|
   | 1 | 2015-01-01 |
   | 2 | 2015-01-01 |
   |  12 | 2014-12-27 |
   | 13 | 2014-12-16 |


Now we can query for DAU and MAU as follows:

SELECT     '2015-01-01' AS date,
SUM(IF(last_active = '2015-01-01', 1, 0)) AS dau,
SUM(IF(last_active > '2014-12-01' AND last_active <= '2015-01-01', 1, 0)) AS mau,
FROM user_last_active
WHERE last_active > '2014-12-01'
AND last_active <= '2015-01-01'
GROUP BY date;


Pros:

One row per user. ~1.2B rows instead of 1 trillion rows per day.
Use B-tree index on last_active to make even faster.
Don't need DISTINCT clause
Can calculate any N-day active users
Cons:
Need to update the newtable each day



[edit]2) Employee Salary

Suppose we have an employee table containing salaries.

   employees
   +--------+----+---------+---------+
    | name | id | dept | salary |
    +--------+----+---------+---------+
    | John | 1 | SW | 70000 |
    | Bob | 2 | SW | 90000 |
    | Simon  | 3 | Data | 95000 |
    | Andy | 4 | Data | 50000 |
    | Eric | 5 | Legal   | 60000 |
    | Matt | 6 | Legal | 100000
    | +--------+----+---------+---------+


a) For each department, find the highest paid person and their salary.

SELECT e.dept, a.max_salary
FROM
(SELECT dept, MAX(salary) AS max_salary FROM employees   GROUP BY dept ) a
JOIN employees e
ON e.salary = a.max_salary
AND e.dept = a.dept;


b) Find the 2nd highest salary in the company.

SELECT MAX(salary) FROM employees
      WHERE salary NOT IN (SELECT MAX(salary) FROM employees)
-- or WHERE salary != (SELECT MAX(salary) FROM employees)
-- or WHERE salary <> (SELECT MAX(salary) FROM employees)

Logic: Eliminate the max salary from the employees table and then take the max salary of that new set to get the 2nd highest salary.


c) Find the N-th highest salary in the company.

This is a more advanced question.



[edit]3) Max Employee ID Without Max Function (use table from last question)

Find the max employee id without using the MAX, or TOP or ORDER function? Assume no duplicates.

Step 1: generate the cartesian product using an inequality self join

SELECT a.id, b.id FROM employees a JOIN employees b ON a.id < b.id;

   +------+------+     | a.id | b.id | +------+------+
   | 1 | 2 |
   | 1 | 3 |
   |   2 | 3 |
   | 1 | 4 |
   | 2 |   4 |
   | 3 | 4 |
   | 1 | 5 |
   | 2 | 5 |
   | 3 | 5 |
   | 4 |  5 |
   | 1 | 6 |
   | 2 | 6 |
   |  3 | 6 |
   | 4 | 6 |
   | 5 | 6 |
   +------+------+

Step 2: The values in a.id represent everything EXCEPT the max number. Use a NOT IN clause to get the id from employees that are not in the a.id column

SELECT DISTINCT id FROM employees WHERE id NOT IN
( SELECT a.id     FROM employees a     JOIN employees b ON a.id < b.id );

Could also use NOT EXISTS instead of NOT IN

Followup: What change would you make to get the MIN instead of the MAX?
The values in a.id represent everything EXCEPT the min number. So change the exclusion query in the nested join from a.id to b.id.



[edit]4) Timezone Adjustments

Consider a table that logs the revenue made by ad in each hour. Here measure all our ad data in Pacific Standard Time (PST) and we had the following simple table:

   ads    +----------+-------+----------+---------+
   | date_pst | ad_id | hour_pst | revenue |
   +----------+-------+----------+---------+
   | 1/2 | 1 | 1 | 10 | | 1/2 | 1 | 13 | 20 | | 1/2
   | 2 | 12 | 30 | | 1/2 | 2 | 20 | 10 | | 1/2
   | 3 | 6      | 0 | | 1/2 | 3 | 1 | 10 |
   +----------+-------+----------+---------+


a) WARMUP: Write a query to get the revenue made for each ad_id and for each date_pst.

   +----------+-------+---------------+
   | date_pst | ad_id | total_revenue |
   +----------+-------+---------------+
   | 1/2 | 1 | 30 |
   | 1/2 | 2 | 40 |
   | 1/2 | 3 | 10 |
   +----------+-------+---------------+

SELECT date_pst, ad_id, SUM(revenue) AS total_revenue FROM ads GROUP BY date_pst, ad_id;


In reality, advertisers come from all over the world, so each ad account is created in a city, which resides in a specific timezone. The timezone offset is defined in the timezone table.

   ads
   +----------+-------+----------+---------+------------+
   | date_pst | ad_id | hour_pst | revenue | acct_city |
   +----------+-------+----------+---------+------------+
   | 1/2 | 1 | 1 | 10 | 'LA' |
   | 1/2 | 1 | 13 | 20 | 'LA' |
   | 1/2      | 2 | 12 | 30 | 'Paris' |
   | 1/2 | 2 | 20 | 10 | 'Paris' |
   | 1/2 | 3 | 6      | 0 | 'Honolulu' |
   | 1/2 | 3 | 1 | 10 | 'Honolulu' |
   +----------+-------+----------+---------+------------+

   timezone
   +------------+------------+
   | acct_city | pst_offset |
   +------------+------------+
   | 'LA' | 0 | | 'Paris' | 9 |
   | 'Honolulu' |   -2 |
   +------------+------------+


b) Write a query to get the revenue made for each ad_id and for each date -- in the account's timezone

SELECT     CASE         WHEN a.hour_pst + t.pst_offset > 23 THEN '1/3'
WHEN a.hour_pst + t.pst_offset < 0  THEN '1/1'  ELSE '1/2'     END AS date_local,
ad_id,
SUM(revenue) AS total_revenue
FROM ads a JOIN timezone t ON a.acct_city = t.acct_city GROUP BY 1,2;
